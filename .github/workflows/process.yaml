name: run-process
on:
  workflow_dispatch: {}   # 手动触发

jobs:
  run:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install deps
        run: pip install -r requirements.txt

      - name: Prepare config
        run: |
          mkdir -p subscribe/config
          cp subscribe/config/config.default.json subscribe/config/config.json

      # 这个仓库的 -c 是布尔开关，不能跟路径
      - name: Run process
        shell: bash
        run: |
          set -eux
          python subscribe/process.py -c || python subscribe/process.py

      - name: Inspect outputs
        shell: bash
        run: |
          echo "WORKSPACE=$(pwd)"
          ls -lah || true
          ls -lah subscribe || true
          ls -lah subscribe/out || true
          ls -lah clash || true

      # 自动挑一个最合适的 YAML 产物
      - name: Locate YAML output
        id: locate
        shell: bash
        run: |
          set -e
          pick=""
          for p in clash/proxies.yaml proxies.yaml subscribe/out/clash.yaml subscribe/out/proxies.yaml; do
            [ -f "$p" ] && { pick="$p"; break; }
          done
          [ -z "$pick" ] && pick=$(find . -type f \( -name "*.yaml" -o -name "*.yml" \) -printf "%T@ %p\n" | sort -nr | head -n 1 | cut -d' ' -f2- || true)
          pick="${pick#./}"
          echo "file=$pick" >> "$GITHUB_OUTPUT"
          echo "Picked file: ${pick:-<none>}"

      # 先尝试 PATCH 你提供的 Gist；404 则自动新建，并把新 ID 保存出来
      - name: Upsert Gist (update or create)
        id: upsert
        if: ${{ steps.locate.outputs.file != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GIST_PAT }}
          script: |
            const fs = require('fs');
            const path = '${{ steps.locate.outputs.file }}';
            const content = fs.readFileSync(path, 'utf8');
            const gistId = (process.env.GIST_ID || '').trim();

            async function update() {
              return await github.request('PATCH /gists/{gist_id}', {
                gist_id: gistId,
                files: { 'clash.yaml': { content } }
              });
            }

            try {
              if (gistId) {
                await update();
                core.info(`Updated existing gist ${gistId}`);
                return;
              }
            } catch (e) {
              if (e.status !== 404) throw e;
              core.warning('Gist not found or no access; creating a new secret gist.');
            }

            const resp = await github.request('POST /gists', {
              public: false,
              description: 'Auto-created by run-process workflow',
              files: { 'clash.yaml': { content } }
            });
            const newId = resp.data.id;
            fs.writeFileSync('NEW_GIST_ID.txt', newId);
            core.setOutput('new_id', newId);
        env:
          GIST_ID: ${{ secrets.GIST_LINK }}

      - name: Upload new gist id (if created)
        if: ${{ steps.upsert.outputs.new_id != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: new-gist-id
          path: NEW_GIST_ID.txt

      - name: Upload artifacts (all YAML)
        uses: actions/upload-artifact@v4
        with:
          name: outputs
          path: |
            **/*.yaml
            **/*.yml
            subscribe/out/**
          if-no-files-found: warn
