name: run-process
on:
  workflow_dispatch: {}   # 手动触发

jobs:
  run:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install deps
        run: pip install -r requirements.txt

      # 准备配置：默认模板复制为可编辑配置
      - name: Prepare config
        run: |
          mkdir -p subscribe/config
          cp subscribe/config/config.default.json subscribe/config/config.json

      # 关键：这个仓库里 -c 是布尔开关，不能跟路径
      - name: Run process
        shell: bash
        run: |
          set -eux
          python subscribe/process.py -c || python subscribe/process.py

      # 打印目录，便于排查
      - name: Inspect outputs
        shell: bash
        run: |
          echo "WORKSPACE=$(pwd)"
          ls -lah || true
          ls -lah subscribe || true
          ls -lah subscribe/out || true
          ls -lah clash || true

      # 自动定位“可运行的 Clash 配置”：
      # 1) 优先常见成品路径
      # 2) 否则在所有 *.yaml/*.yml 里挑“包含 proxies/proxy-providers/proxy-groups 顶层键”的，取体积最大的那个
      - name: Locate runnable Clash YAML
        id: locate
        shell: bash
        run: |
          set -e
          pick=""
          # 优先候选
          for p in clash/proxies-meta.yaml clash/proxies.yaml proxies-meta.yaml proxies.yaml subscribe/out/proxies.yaml; do
            [ -f "$p" ] && { pick="$p"; break; }
          done
          # 自动筛选含关键段落的 YAML
          if [ -z "$pick" ]; then
            mapfile -t files < <(find . -type f \( -name "*.yaml" -o -name "*.yml" \) -print)
            best_size=0
            best_file=""
            for f in "${files[@]}"; do
              # 只认真正可导入 Clash 的文件
              if grep -Eq '^(proxies|proxy-providers|proxy-groups):' "$f"; then
                sz=$(wc -c < "$f")
                if [ "$sz" -gt "$best_size" ]; then
                  best_size=$sz
                  best_file="$f"
                fi
              fi
            done
            pick="$best_file"
          fi
          pick="${pick#./}"
          echo "file=$pick" >> "$GITHUB_OUTPUT"
          echo "Picked runnable YAML: ${pick:-<none>}"

      # 用官方 Action 更新到你的 Gist（文件名统一叫 clash.yaml）
      - name: Update Gist via GitHub API
        if: ${{ steps.locate.outputs.file != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GIST_PAT }}   # 你已有的 PAT（需 gist 权限）
          script: |
            const fs = require('fs');
            const p = '${{ steps.locate.outputs.file }}';
            const content = fs.readFileSync(p, 'utf8');
            await github.request('PATCH /gists/{gist_id}', {
              gist_id: process.env.GIST_ID,
              files: { 'clash.yaml': { content } }
            });
        env:
          GIST_ID: ${{ secrets.GIST_LINK }}       # 你已有的 Gist ID（注意是纯ID，不是整条URL）

      # 打包所有 YAML（不管是不是最终成品），方便你下载对比
      - name: Upload artifacts (all YAML)
        uses: actions/upload-artifact@v4
        with:
          name: outputs
          path: |
            **/*.yaml
            **/*.yml
            subscribe/out/**
          if-no-files-found: warn
