name: Process
on:
  schedule:
    - cron: "05 03 * * *"
    - cron: "05 11 * * *"
  workflow_dispatch:

env:
  TZ: Asia/Shanghai
  SUBSCRIBE_CONF: ${{ secrets.SUBSCRIBE_CONF }}
  PUSH_TOKEN: ${{ secrets.PUSH_TOKEN }}
  REACHABLE: ${{ vars.REACHABLE }}
  SKIP_ALIVE_CHECK: ${{ vars.SKIP_ALIVE_CHECK }}
  SKIP_REMARK: ${{ vars.SKIP_REMARK }}
  WORKFLOW_MODE: ${{ vars.WORKFLOW_MODE }}
  ENABLE_SPECIAL_PROTOCOLS: ${{ vars.ENABLE_SPECIAL_PROTOCOLS }}

jobs:
  process:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Prepare
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"
          architecture: "x64"
          cache: "pip"

      - name: Install
        run: pip3 install -r requirements.txt

      # 安装 jq
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # 先校验 Secrets 是否存在（不打印值）
      - name: Validate secrets (non-empty)
        env:
          GIST_LINK: ${{ secrets.GIST_LINK }}
          GIST_PAT:  ${{ secrets.GIST_PAT }}
        run: |
          set -eux
          test -n "$GIST_LINK" || (echo "GIST_LINK is empty"; exit 1)
          test -n "$GIST_PAT"  || (echo "GIST_PAT is empty";  exit 1)
          echo "GIST_LINK length: ${#GIST_LINK}"
          echo "GIST_PAT   length: ${#GIST_PAT}"

      # 用 PAT 测试一下能否访问 Gist（200 才算通过）
      - name: Check PAT can access Gist
        env:
          GIST_LINK: ${{ secrets.GIST_LINK }}
          GIST_PAT:  ${{ secrets.GIST_PAT }}
        run: |
          set -eux
          # 如果你填的是 ID，这里拼出 API；如果你填的是完整 URL，这个请求也会给 404。
          # 建议 GIST_LINK 填“ID”（链接最后那串）。
          curl -s -o /dev/null -w "%{http_code}\n" \
            -H "Authorization: token $GIST_PAT" \
            "https://api.github.com/gists/$GIST_LINK" | tee /tmp/code
          code=$(cat /tmp/code)
          if [ "$code" != "200" ]; then
            echo "PAT/GIST_LINK check failed, http_code=$code"
            exit 1
          fi

      # 生成运行时 config.json，并注入 gist 推送配置
      - name: Build runtime config.json (inject push->gist)
        env:
          GIST_LINK: ${{ secrets.GIST_LINK }}
          GIST_PAT:  ${{ secrets.GIST_PAT }}
        run: |
          set -eux
          # 确保默认配置存在
          test -f subscribe/config/config.default.json

          cp subscribe/config/config.default.json config.json

          jq --arg tok "${GIST_PAT}" --arg id "${GIST_LINK}" '
            .storage.engine = "gist" |
            .storage.base   = "https://api.github.com" |
            .storage.domain = "https://gist.github.com" |
            .storage.token  = $tok |
            .storage.items  = {
              "xxx-clash": { "id": $id, "filename": "clash.yaml" }
            }
          ' config.json > config.tmp && mv config.tmp config.json

          echo "==== resolved config (token redacted) ===="
          sed -E 's/"token"\s*:\s*"[^"]+"/"token":"***"/' config.json

      # 真正运行脚本（显式携带 config）
      - name: Process
        run: |
          set -eux
          python -u subscribe/process.py --config config.json --overwrite

      # 查看根目录是否产出了 clash.yaml
      - name: List outputs
        run: |
          set -eux
          ls -al
          [ -f clash.yaml ] && echo "Found clash.yaml in repo root" || echo "No clash.yaml in repo root"

      - name: Timestamp
        run: date
